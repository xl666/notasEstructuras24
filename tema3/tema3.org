#+title: Cadenas de texto

* Generalidades sobre  texto
- El texto es el tipo de dato m√°s general, con texto se puede representar cualquier otro tipo de dato
- Los sistemas operativos tratan de forma especial al texto, ya que muchas cosas en el sistema se representan como texto:
  + Interfaz de l√≠nea de comandos
  + Archivos de configuraci√≥n
  + Bit√°coras del sistema
  + Entrada y salida est√°ndar
  + Datos intercambiados por protocolos (como http)
  + Scripts
- Saber manipular texto es esencial en la automatizaci√≥n de tareas
- Solo se necesita texto para interactuar con una computadora (los
  administradores de servidores saben esto bien)
- Una computadora s√≥lo maneja n√∫meros binarios, esto es, ceros y unos

** Terminolog√≠a
*** Texto plano:
  + Se refiere al texto que no ha sido procesado de forma especial
  + Cuando hablamos de texto en este curso, hacemos referencia a texto plano
  + Un archivo de texto plano, s√≥lo tiene texto, no lo acompa√±a otros
    datos binarios
  + Por ejemplo, el texto que escribes en un procesador de texto como
    word, no es texto plano, dado que se codifica a un formato
    propietario de Microsoft, que puede incluir im√°genes u otros
    elementos binarios
  + El c√≥digo que escribes en tu editor es un ejemplo de texto plano,
    toda la programaci√≥n se hace en texto plano
  + El texto plano est√° estandarizado y no es propiedad de ninguna
    organizaci√≥n u empresa (es libre)
  + Si valoras tu informaci√≥n usa formatos libres, como el texto plano
*** Parsing de texto
- Se refiere en general a  procesar texto
- Est√° asociado al procesamiento en modo lectura (sin modificar el
  texto original)
- Se utiliza para  lograr algunas de las  siguientes cosas:
  + Recuperar elementos particulares en el texto
  + Transformar el texto entre formatos (renderizar a imagen por ejemplo)
  + Construir una estructura de datos que facilite el acceso a
    elementos: por ejemplo, construir un √°rbol a partir de un archivo
    =html=
- En computaci√≥n se cuenta con una herramienta general muy poderosa para el
  parsing de texto: expresiones regulares (es un tema avanzado para
  este curso, lo ven m√°s adelante en la carrera)

*** Parsers de texto
- Son herramientas creadas para facilitar el parsing de alg√∫n formato
  de texto en particular
- Suelen usar expresiones regulares
- Por ejemplo, si quieres parsear un archivo =html= conviene primero
  buscar si existe un parser para =html=
- El parser normalmente le entrega al programador (u otras partes del programa) alguna estructura de
  datos m√°s f√°cil de procesar, un ejemplo com√∫n es un √°rbol
- Cabe decir que muchos tipos de programas como los compiladores y los
  navegadores web incluyen sus propios parsers
- Por ejemplo, un compilador primero parsea (mediante un parser del
  lenguaje de programaci√≥n) el c√≥digo fuente y luego construye un
  √°rbol sint√°ctico, con el cual es m√°s f√°cil generar instrucciones
  
* Est√°ndares de texto  
- Dado que las computadoras s√≥lo pueden manejar n√∫meros, es necesario contar con est√°ndares para mapear entre si n√∫meros y caracteres de texto
- A estos est√°ndares tambi√©n se les conoce como "charsets"
- A un mapeo en particular entre car√°cter y un n√∫mero se le conoce como "code point"
- Existen muchos charsets, en este curso se mencionar√°n dos:

**  ASCII:
- Es el est√°ndar cl√°sico
- Originalmente pensado s√≥lo para  el alfabeto en ingl√©s
- Define 128 caracteres, incluyendo d√≠gitos, letras (may√∫sculas y min√∫sculas) y caracteres especiales
- Para espa√±ol se tiene una versi√≥n extendida de ascii con 256
  caracteres (ASCII extendido)
- En un solo byte (hasta 256 valores) se pueden representar todos
  los caracteres
- Muchos caracteres son "no imprimibles" esto es, no los puedes
  ver en una pantalla, por ejemplo el car√°cter de =backspace=

[[file:./ascii.png]]

*** Unicode:
- Un problema de ASCII es que no cubre muchos de los caracteres de
      varios idiomas: japones, griego, √°rabe, etc.
- Esto obligaba a tener muchos est√°ndares diferentes, lo cual
  causa muchos problemas de compatibilidad
- En la era de Internet este es un problema serio
- Unicode es el est√°ndar moderno que cubre todos los posibles
  caracteres de todos los idiomas
- Actualmente tiene definidos al rededor de 140,000 caracteres con
  espacio para definir m√°s si hace falta
- Esto incluye cosas como emoticones
- Es una extensi√≥n de ASCII, esto es, los primeros 256 caracteres
  son los mismos
- Un problema de unicode es que ya no basta un byte para
  representar caracteres

- En python, la funci√≥n =ord= regresa el code point correspondiente a
  un car√°cter 
- Mientras que la funci√≥n =chr= hace la operaci√≥n inversa

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  print(ord('a'))
  print(ord('A'))

  print(chr(97))
  print(chr(65))

  # un car√°cter en japones 
  print(ord('„Åì'))

  # un emoji
  print(ord('üòÄ'))
#+end_src

#+RESULTS:
: 97
: 65
: a
: A
: 12371
: 128512


** Codificaci√≥n de texto
- Se  refiere a c√≥mo representar caracteres en c√≥digo binario
- Esto permite hacer conversiones de texto a binario y vise-versa
- Esto es necesario, por ejemplo, al querer abrir un archivo de texto
  (internamente es binario, como todo),
  para que el sistema pueda mostrar los caracteres adecuados
- En =ASCII= la conversi√≥n es muy simple, cada byte es un car√°cter
- En Unicode la cosa es m√°s complicada, se requieren a su vez
  est√°ndares de codificaci√≥n
- Estos est√°ndares establecen la correspondencia entre bytes y
  caracteres
- Los archivos de texto tienen un metadato conocido como =BOM= que le
  indica al sistema el est√°ndar  de codificaci√≥n con que fue almacenado 
- Existen muchos est√°ndares de codificaci√≥n para Unicode
- Tratar diferentes codificaciones al mismo tiempo es una tarea en
  extremo compleja y propensa a errores
- Por esta raz√≥n, en la actualidad la mayor√≠a de sistemas adoptan el
  est√°ndar =utf-8= para todo
- Este est√°ndar usa de 1 a 4 bytes (dependiendo del caracter) para
  representar caracteres y se considera eficiente (no desperdicia
  mucho espacio)
- Trata de usar siempre Unicode y =utf-8=
- Lo anterior es f√°cil en cualquier sistema diferente de Windows, ya
  que usan =utf-8= por defecto
- Si tu sistema no usa =utf-8= por defecto, puede ser que tengas que guardar
  manualmente con esa codificaci√≥n (en las opciones de guardar como de
  tu editor)
- Si guardaste un archivo (c√≥digo por ejemplo) en una codificaci√≥n
  diferente a =utf-8= y lo intentas abrir como =utf-8= (cosa que puede
  pasar si creas un archivo en windows y luego lo quieres abrir en
  Linux) es posible que parte del texto se visualice corrupto (sobre
  todo en caracteres que rebasen ASCII)

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    # Revisar sistema de codificaci√≥n por defecto del SO

    import sys
    print(sys.getdefaultencoding())
  #+end_src

  #+RESULTS:
  : utf-8
  
#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  # Ejemplo de codificaci√≥n simple (solo caracteres ASCII)
  s = 'hola'
  print(len(s))
  b = s.encode('utf-8') # convertir a binario
  print(b) # ver cadena binaria 
  print(list(b)) # ver valores de bytes
  print(b.decode('utf-8')) # regresar a texto
#+end_src      

#+RESULTS:
: 4
: b'hola'
: [104, 111, 108, 97]
: hola


#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  # Ejemplo de codificaci√≥n m√°s complicado
  s = '„Åì„Çì„Å´„Å°„ÅØ' # hola en japones
  print(len(s)) # python cuenta caracteres, no bytes
  b = s.encode('utf-8') # convertir a binario
  print(b) # ver cadena binaria
  print(len(b)) # hay m√°s de 5 bytes
  print(list(b)) # ver valores de bytes
  print(b.decode('utf-8')) # regresar a texto
#+end_src

#+RESULTS:
: 5
: b'\xe3\x81\x93\xe3\x82\x93\xe3\x81\xab\xe3\x81\xa1\xe3\x81\xaf'
: 15
: [227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175]
: „Åì„Çì„Å´„Å°„ÅØ

- Python (a partir de su versi√≥n 3) es un lenguaje dise√±ado para trabajar con Unicode (esto no es
  as√≠ para muchos lenguajes que trabajan por defecto con ASCII)
- Esto le facilita mucho la vida a los programadores
- Por ejemplo, en el c√≥digo de antes, la longitud de la cadena "„Åì„Çì„Å´„Å°„ÅØ" es 5, a pesar de que internamente puedan ser varios bytes
  (dependiendo de la codificaci√≥n)
- A menos que tengas que hacer conversiones entre texto en diferentes
  est√°ndares, no es necesario preocuparse mucho de c√≥mo se maneja
  internamente el texto
- Mantente usando siempre =utf-8= y todo va a estar bien

* Tipo =str=

* Creaci√≥n de cadenas

* Recorrido de cadenas

* Subcadenas

* Operaciones sobre cadenas

* Plantillas de texto 

