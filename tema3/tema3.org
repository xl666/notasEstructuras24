#+title: Tema 3: Cadenas de texto

* Generalidades sobre  texto
- El texto es el tipo de dato m√°s general, con texto se puede representar cualquier otro tipo de dato
- Los sistemas operativos tratan de forma especial al texto, ya que muchas cosas en el sistema se representan como texto:
  + Interfaz de l√≠nea de comandos
  + Archivos de configuraci√≥n
  + Bit√°coras del sistema
  + Entrada y salida est√°ndar
  + Datos intercambiados por protocolos (como http)
  + Scripts
- Saber manipular texto es esencial en la automatizaci√≥n de tareas
- Solo se necesita texto para interactuar con una computadora (los
  administradores de servidores saben esto bien)
- Una computadora s√≥lo maneja n√∫meros binarios, esto es, ceros y unos

** Terminolog√≠a
*** Texto plano:
  + Se refiere al texto que no ha sido procesado de forma especial
  + Cuando hablamos de texto en este curso, hacemos referencia a texto plano
  + Un archivo de texto plano, s√≥lo tiene texto, no lo acompa√±a otros
    datos binarios
  + Por ejemplo, el texto que escribes en un procesador de texto como
    word, no es texto plano, dado que se codifica a un formato
    propietario de Microsoft, que puede incluir im√°genes u otros
    elementos binarios
  + El c√≥digo que escribes en tu editor es un ejemplo de texto plano,
    toda la programaci√≥n se hace en texto plano
  + El texto plano est√° estandarizado y no es propiedad de ninguna
    organizaci√≥n u empresa (es libre)
  + Si valoras tu informaci√≥n usa formatos libres, como el texto plano
*** Parsing de texto
- Se refiere en general a  procesar texto
- Est√° asociado al procesamiento en modo lectura (sin modificar el
  texto original)
- Se utiliza para  lograr algunas de las  siguientes cosas:
  + Recuperar elementos particulares en el texto
  + Transformar el texto entre formatos (renderizar a imagen por ejemplo)
  + Construir una estructura de datos que facilite el acceso a
    elementos: por ejemplo, construir un √°rbol a partir de un archivo
    =html=
- En computaci√≥n se cuenta con una herramienta general muy poderosa para el
  parsing de texto: expresiones regulares (es un tema avanzado para
  este curso, lo ven m√°s adelante en la carrera)

*** Parsers de texto
- Son herramientas creadas para facilitar el parsing de alg√∫n formato
  de texto en particular
- Suelen usar expresiones regulares
- Por ejemplo, si quieres parsear un archivo =html= conviene primero
  buscar si existe un parser para =html=
- El parser normalmente le entrega al programador (u otras partes del programa) alguna estructura de
  datos m√°s f√°cil de procesar, un ejemplo com√∫n es un √°rbol
- Cabe decir que muchos tipos de programas como los compiladores y los
  navegadores web incluyen sus propios parsers
- Por ejemplo, un compilador primero parsea (mediante un parser del
  lenguaje de programaci√≥n) el c√≥digo fuente y luego construye un
  √°rbol sint√°ctico, con el cual es m√°s f√°cil generar instrucciones
  
* Est√°ndares de texto  
- Dado que las computadoras s√≥lo pueden manejar n√∫meros, es necesario contar con est√°ndares para mapear entre si n√∫meros y caracteres de texto
- A estos est√°ndares tambi√©n se les conoce como "charsets"
- A un mapeo en particular entre car√°cter y un n√∫mero se le conoce como "code point"
- Existen muchos charsets, en este curso se mencionar√°n dos:

**  ASCII:
- Es el est√°ndar cl√°sico
- Originalmente pensado s√≥lo para  el alfabeto en ingl√©s
- Define 128 caracteres, incluyendo d√≠gitos, letras (may√∫sculas y min√∫sculas) y caracteres especiales
- Para espa√±ol se tiene una versi√≥n extendida de ascii con 256
  caracteres (ASCII extendido)
- En un solo byte (hasta 256 valores) se pueden representar todos
  los caracteres
- Muchos caracteres son "no imprimibles" esto es, no los puedes
  ver en una pantalla, por ejemplo el car√°cter de =backspace=

[[file:./ascii.png]]

*** Unicode:
- Un problema de ASCII es que no cubre muchos de los caracteres de
      varios idiomas: japones, griego, √°rabe, etc.
- Esto obligaba a tener muchos est√°ndares diferentes, lo cual
  causa muchos problemas de compatibilidad
- En la era de Internet este es un problema serio
- Unicode es el est√°ndar moderno que cubre todos los posibles
  caracteres de todos los idiomas
- Actualmente tiene definidos al rededor de 140,000 caracteres con
  espacio para definir m√°s si hace falta
- Esto incluye cosas como emoticones
- Es una extensi√≥n de ASCII, esto es, los primeros 256 caracteres
  son los mismos
- Un problema de unicode es que ya no basta un byte para
  representar caracteres

- En python, la funci√≥n =ord= regresa el code point correspondiente a
  un car√°cter 
- Mientras que la funci√≥n =chr= hace la operaci√≥n inversa

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  print(ord('a'))
  print(ord('A'))

  print(chr(97))
  print(chr(65))

  # un car√°cter en japones 
  print(ord('„Åì'))

  # un emoji
  print(ord('üòÄ'))
#+end_src

#+RESULTS:
: 97
: 65
: a
: A
: 12371
: 128512


** Codificaci√≥n de texto
- Se  refiere a c√≥mo representar caracteres en c√≥digo binario
- Esto permite hacer conversiones de texto a binario y vise-versa
- Esto es necesario, por ejemplo, al querer abrir un archivo de texto
  (internamente es binario, como todo),
  para que el sistema pueda mostrar los caracteres adecuados
- En =ASCII= la conversi√≥n es muy simple, cada byte es un car√°cter
- En Unicode la cosa es m√°s complicada, se requieren a su vez
  est√°ndares de codificaci√≥n
- Estos est√°ndares establecen la correspondencia entre bytes y
  caracteres
- Los archivos de texto tienen un metadato conocido como =BOM= que le
  indica al sistema el est√°ndar  de codificaci√≥n con que fue almacenado 
- Existen muchos est√°ndares de codificaci√≥n para Unicode
- Tratar diferentes codificaciones al mismo tiempo es una tarea en
  extremo compleja y propensa a errores
- Por esta raz√≥n, en la actualidad la mayor√≠a de sistemas adoptan el
  est√°ndar =utf-8= para todo
- Este est√°ndar usa de 1 a 4 bytes (dependiendo del caracter) para
  representar caracteres y se considera eficiente (no desperdicia
  mucho espacio)
- Trata de usar siempre Unicode y =utf-8=
- Lo anterior es f√°cil en cualquier sistema diferente de Windows, ya
  que usan =utf-8= por defecto
- Si tu sistema no usa =utf-8= por defecto, puede ser que tengas que guardar
  manualmente con esa codificaci√≥n (en las opciones de guardar como de
  tu editor)
- Si guardaste un archivo (c√≥digo por ejemplo) en una codificaci√≥n
  diferente a =utf-8= y lo intentas abrir como =utf-8= (cosa que puede
  pasar si creas un archivo en windows y luego lo quieres abrir en
  Linux) es posible que parte del texto se visualice corrupto (sobre
  todo en caracteres que rebasen ASCII)

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    # Revisar sistema de codificaci√≥n por defecto del SO

    import sys
    print(sys.getdefaultencoding())
  #+end_src

  #+RESULTS:
  : utf-8
  
#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  # Ejemplo de codificaci√≥n simple (solo caracteres ASCII)
  s = 'hola'
  print(len(s))
  b = s.encode('utf-8') # convertir a binario
  print(b) # ver cadena binaria
  print(len(b))
  print(list(b)) # ver valores de bytes
  print(b.decode('utf-8')) # regresar a texto
#+end_src      

#+RESULTS:
: 4
: b'hola'
: 4
: [104, 111, 108, 97]
: hola


#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  # Ejemplo de codificaci√≥n m√°s complicado
  s = '„Åì„Çì„Å´„Å°„ÅØ' # hola en japones
  print(len(s)) # python cuenta caracteres, no bytes
  b = s.encode('utf-8') # convertir a binario
  print(b) # ver cadena binaria
  print(len(b)) # hay m√°s de 5 bytes
  print(list(b)) # ver valores de bytes
  print(b.decode('utf-8')) # regresar a texto
#+end_src

#+RESULTS:
: 5
: b'\xe3\x81\x93\xe3\x82\x93\xe3\x81\xab\xe3\x81\xa1\xe3\x81\xaf'
: 15
: [227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175]
: „Åì„Çì„Å´„Å°„ÅØ

- Python (a partir de su versi√≥n 3) es un lenguaje dise√±ado para trabajar con Unicode (esto no es
  as√≠ para muchos lenguajes que trabajan por defecto con ASCII)
- Esto le facilita mucho la vida a los programadores
- Por ejemplo, en el c√≥digo de antes, la longitud de la cadena "„Åì„Çì„Å´„Å°„ÅØ" es 5, a pesar de que internamente puedan ser varios bytes
  (dependiendo de la codificaci√≥n)
- A menos que tengas que hacer conversiones entre texto en diferentes
  est√°ndares, no es necesario preocuparse mucho de c√≥mo se maneja
  internamente el texto
- Mantente usando siempre =utf-8= y todo va a estar bien

* Manejo de cadenas

** Tipo =str=
- Es el tipo b√°sico para manejar cadenas, con soporte nativo de Unicode
- Definido en la el n√∫cleo del lenguaje (no hay que importar nada para
  usarlas)
- Existen otros tipos relacionados, pero en el curso s√≥lo se ver√° este tipo
- Es un tipo lineal, est√°tico y no mutable
- En lenguajes como =C= es un arreglo de caracteres (en Python no es
  necesariamente as√≠)
- Cualquier tipo de dato puede potencialmente transformarse a cadena
  mediante la funci√≥n =str=
- Dado que es lineal es indexable

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  s = 'hola mundo'
  print(s[0])  # primera
  print(s[-1]) # √∫ltima
  print(s[len(s)-1]) # tambi√©n √∫ltima
#+end_src  

#+RESULTS:
: h
: o
: o

** Creaci√≥n de cadenas
- Existen dos formas literales v√°lidas:
  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    'Ejemplo de cadena'
    "Ejemplo de cadena"
  #+end_src
- En general se prefiere el estilo de comilla simple (estilo PEP8)
- Se puede usar comilla doble si se quiere tener una comilla simple
  literal, o bien se puede usar el car√°cter de escape (backslash)
- El car√°cter de escape es muy √∫til en varias situaciones y es una
  forma de insertar caracteres especiales no imprimibles como salto de
  l√≠nea y tabulador

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    print("My father's house")
    print('My father\'s house') # se escapa la '
    print('Primera l√≠nea\nSegunda l√≠nea')
    print('\tCon sangr√≠a')
  #+end_src

  #+RESULTS:
  : My father's house
  : My father's house
  : Primera l√≠nea
  : Segunda l√≠nea
  : 	Con sangr√≠a

  - Tambi√©n existen las cadenas multi-linea para lo cual se usa triple
    comilla simple o doble

    #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
      s = '''Esta es una
      cadena de varias l√≠neas
      √∫til para crear formatos de texto
      o documentar funciones y m√≥dulos
      '''
      print(s)
    #+end_src

#+RESULTS:
: Esta es una
: cadena de varias l√≠neas
: √∫til para crear formatos de texto
: o documentar funciones y m√≥dulos

** Recorrido de cadenas
- Se pueden recorrer los caracteres simplemente con un for:
  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    for caracter in 'hola':
        print(caracter)

  #+end_src

#+RESULTS:
: h
: o
: l
: a

- O al estilo =C=

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  s = 'hola'
  for i in range(len(s)):
      print(s[i])
#+end_src  

#+RESULTS:
: h
: o
: l
: a

** Subcadenas
- Una subcadena es cualquier fragmento de una cadena, desde un solo car√°cter hasta la cadena completa
- La forma m√°s directa que tiene Python para obtener subcadenas es con el formato de "rebanadas" (slices)
- Con este m√©todo cada subcadena es una nueva cadena 
- Este m√©todo funciona para otras estructuras lineales (como listas)
- El formato de rebanadas requiere de dos √≠ndices (pude ser cualquier expresi√≥n entera):
  + √çndice izquierdo inclusivo: posici√≥n inicial a partir de la cual se quiere obtener la subcadena
  + √çndice derecho no inclusivo: posici√≥n final hasta la que se quiere incluir la subcadena, siempre se toma una posici√≥n antes

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  s = 'hola'
  print(s[0:4]) # copia completa
  print(s[:len(s)]) # lo mismo
  print(s[:]) # otra vez lo mismo

  # todos menos el primer caracter
  print(s[1:])

  # todos menos el √∫ltimo
  print(s[:-1])

  # las dos letras de enmedio
  print(s[1:3])
#+end_src    

#+RESULTS:
: hola
: hola
: hola
: ola
: hol
: ol    

** Operaciones sobre cadenas

*** Longitud
- =len= es una funci√≥n gen√©rica de Python que permite determinar el
  n√∫mero de elementos en varias estructuras de datos
- En el caso de una cadena establece el n√∫mero de caracteres (sin
  importar su tama√±o en bytes)

*** Concatenaci√≥n
- Permite unir dos cadenas creando una nueva
- Se utiliza el operador =+=

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
  s = 'hola ' + 'mundo'
  print(s)

  #+end_src  

#+RESULTS:
: hola mundo

*** strip
- Quita caracteres de espaciadores a izquierda y derecha
  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    s = '   hola    mundo    \n\n\n'.strip()
    print(s)
  #+end_src

#+RESULTS:
: hola    mundo


*** split
- Dada una cadena separadora, genera una lista de cadenas considerando
  el separador

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    s = 'nombre,edad,carrera,matricula'
    partes = s.split(',')
    print(partes)

    s = 'hola-->mundo'
    print(s.split('-->'))
  #+end_src

  #+RESULTS:
  : ['nombre', 'edad', 'carrera', 'matricula']

*** startswith
- Regresa verdadero si una cadena empieza con una subcadena

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    print('hola mundo'.startswith('hola'))
  #+end_src

#+RESULTS:
: True

*** endswith
- Regresa verdadero si una cadena termina con cierta subcadena

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    print('hola mundo'.endswith('mundo'))
  #+end_src

#+RESULTS:
: True

*** join
- Concatena cadenas en una lista de cadenas, usando la cadena actual
  como separador

#+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
print(','.join(['hola', 'mundo', 'mundial']))
#+end_src

#+RESULTS:
: hola,mundo,mundial

- Si necesitas modificar caracteres de una cadena, una forma simple y eficiente
  de hacerlo es primero convertir la cadena a lista, mediante la
  funci√≥n =list= y luego de las modificaciones regresar a cadena con
  la funci√≥n =join= usando la cadena vac√≠a como separador
  
  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    s = 'hola mundo'
    ls = list(s)
    print(ls)
    ls[0] = 'H'
    s = ''.join(ls)
    print(s)
  #+end_src

  #+RESULTS:
  : ['h', 'o', 'l', 'a', ' ', 'm', 'u', 'n', 'd', 'o']
  : Hola mundo


** Plantillas de texto 
- Son una forma conveniente de crear cadenas con espacios que se van a
  rellenar despu√©s
- Son la forma principal de escribir mensajes largos que dependen de
  valores de expresiones (como variables)
- Son reutilizables
- Se basan en dejar espacios reemplazables, tambi√©n llamados =place-holders=
- Existen tres formas principales en Python:
  + Mediante el operador =%=
  + Usando lo funci√≥n =format= de una cadena
  + Usando =cadenas f=

*** Operador =%=
- Las sustituciones son posicionales
- Es conveniente para pocas sustituciones
- Si se sustituye m√°s de un valor es necesario agregar =()= en la
  sustituci√≥n
- Hay varios tipos de =place-holders=, =%s= es el m√°s general

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    s = 'Pepe'
    print('hola %s, c√≥mo estas?' % s )

    nombre = 'Juan'
    edad = 15
    print('Hola %s, tienes %s a√±os' % (nombre, edad))

    plantilla = 'Hola %s, tienes %s a√±os'
    print(plantilla % ('Jos√©', 16))
    print(plantilla % ('Brenda', 21))

  #+end_src

  #+RESULTS:
  : hola Pepe, c√≥mo estas?
  : Hola Juan, tienes 15 a√±os
  : Hola Jos√©, tienes 16 a√±os
  : Hola Brenda, tienes 21 a√±os

*** =format=
- Es una funci√≥n de cadenas para crear plantillas
- Utiliza =place-holders= nombrados
- No es posicional como el operador =%=

  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    plantilla = 'hola {nombre}'
    print(plantilla.format(nombre='Pepe'))

    plantilla = 'Hola {nombre}, tu edad es {edad}, adi√≥s {nombre}'
    print(plantilla.format(edad=18, nombre='Juanito'))
  #+end_src

  #+RESULTS:
  : hola Pepe
  : Hola Juanito, tu edad es 18, adi√≥s Juanito

*** =cadenas f=
- No es exactamente para crear plantillas (dado que no son reutilizables)
- Son una forma conveniente de remplazar un =place-holder= por una variable que ya se tiene
- Se crean poniendo una =f= al inicio de la cadena
  #+begin_src python :session *py* :results output :exports both :tangle /tmp/test.py
    nombre = 'Pepe'
    edad = 18
    print(f'Hola {nombre}, tu edad es {edad}')
  #+end_src

#+RESULTS:
: Hola Pepe, tu edad es 18
